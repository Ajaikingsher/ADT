Single File Programming Question
Problem Statement



You are organizing a charity fundraising event where people can donate money in fixed denominations. You are given a total target amount of N that needs to be collected in various donation combinations.



Your task is to find all unique sets of donation combinations that exactly sum up to N. Each combination can include repeated denominations (like someone donating ₹1 multiple times), but the order doesn't matter — for example, [1, 2, 1] is considered the same as [1, 1, 2] and should be counted only once.



To ensure fairness and clarity, every combination should be:

Represented in non-decreasing order (e.g., [1, 1, 2] instead of [2, 1, 1])



Printed in lexicographically increasing order (sorted as if in a dictionary)



You are to use backtracking to explore all possible valid combinations.

Input format :
The input consists of a single integer, n, which represents the number to be broken down.

Output format :
The output consists of a list of lists, where each inner list represents a possible breakdown of the given number.

Each breakdown is represented as a list of integers that add up to the given number.

The breakdowns are printed in lexicographic order.



Refer to the sample output for formatting specifications.

Code constraints :
In this scenario, the given test cases will fall under the following constraints:

1 ≤ N ≤ 25

Sample test cases :
Input 1 :
1
Output 1 :
[[1]]
Input 2 :
4
Output 2 :
[[1, 1, 1, 1], [1, 1, 2], [1, 3], [2, 2], [4]]
Input 3 :
3
Output 3 :
[[1, 1, 1], [1, 2], [3]]









#include <iostream>
#include <vector>
using namespace std;

void backtrack(int n, int start, vector<int>& curr, vector<vector<int>>& result) {
    if (n == 0) {
        result.push_back(curr);
        return;
    }
    for (int i = start; i <= n; i++) {
        curr.push_back(i);
        backtrack(n - i, i, curr, result);
        curr.pop_back();
    }
}

int main() {
    int n;
    cin >> n;
    vector<vector<int>> result;
    vector<int> curr;
    backtrack(n, 1, curr, result);

    cout << "[";
    for (int i = 0; i < result.size(); i++) {
        cout << "[";
        for (int j = 0; j < result[i].size(); j++) {
            cout << result[i][j];
            if (j != result[i].size() - 1) cout << ", ";
        }
        cout << "]";
        if (i != result.size() - 1) cout << ", ";
    }
    cout << "]";
    return 0;
}

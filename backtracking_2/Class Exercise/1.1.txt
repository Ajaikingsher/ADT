Single File Programming Question
Problem Statement



Aarav is building a simulation tool for chess movements as part of his computer science project. He wants to analyze the movement of a knight on a square chessboard of size n x n. The knight starts from a specific position (row, column) and makes exactly k moves. Each move is chosen uniformly at random from the 8 possible legal knight moves in chess.



Aarav is curious to discover the probability that the knight will still be on the board after making all the k moves.



Your task is to help Aarav by writing a program that calculates this probability.



Example:

Input:

3 2 0 0

Output:

0.06250

Explanation:

There are two moves (to (1,2), (2,1)) that will keep the knight on the board.
From each of those positions, there are also two moves that will keep the knight on the board.
The total probability that the knight stays on the board is 0.0625.
Input format :
The input consists of a single line of input containing four space-separated integers: n k row column

where:

n is the size of the chessboard (number of rows and columns),
k is the number of moves the knight makes,
row is the knight’s starting row (0-indexed),
column is the knight’s starting column (0-indexed).
Output format :
The output prints a single floating-point number rounded to 5 decimal places, representing the probability that the knight remains on the board after k moves.



Refer to the sample output for formatting specifications.

Code constraints :
The given test cases fall under the following constraints:

1 ≤ n ≤ 25

0 ≤ k ≤ 100

0 ≤ row < n

0 ≤ column < n

Sample test cases :
Input 1 :
3 2 0 0
Output 1 :
0.06250
Input 2 :
5 2 2 2
Output 2 :
0.37500











#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, k, row, col;
    cin >> n >> k >> row >> col;

    vector<vector<int>> moves = {
        {2, 1}, {2, -1}, {-2, 1}, {-2, -1},
        {1, 2}, {1, -2}, {-1, 2}, {-1, -2}
    };

    vector<vector<vector<double>>> dp(k + 1, vector<vector<double>>(n, vector<double>(n, 0.0)));
    dp[0][row][col] = 1.0;

    for (int step = 1; step <= k; step++) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (dp[step - 1][i][j] > 0) {
                    for (auto &m : moves) {
                        int ni = i + m[0], nj = j + m[1];
                        if (ni >= 0 && ni < n && nj >= 0 && nj < n) {
                            dp[step][ni][nj] += dp[step - 1][i][j] / 8.0;
                        }
                    }
                }
            }
        }
    }

    double result = 0.0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            result += dp[k][i][j];
        }
    }

    cout << fixed << setprecision(5) << result << endl;
    return 0;
}
